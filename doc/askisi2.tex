%xelatex
\documentclass{article}
\usepackage[margin=1.3in]{geometry}
\usepackage{xltxtra}
\usepackage{xgreek}
\setmainfont[Mapping=tex-text]{Kerkis}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\title{Λειτουργικά Συστήματα Ι, Ασκηση 2}
\author{Σπύρος Σειμένης 5070}

\begin{document}
\maketitle

\section{Εισαγωγή}
Η πλήρης λειτουργία του κώδικα περιγράφεται αναλυτικά με σχόλια μέσα στα αρχεία. Παρακάτω περιγράφω τις δομές που έχω χρησιμοποιήσει και μια εκτέλεση του προγράμματος, δεν θα αναφερθώ σε λεπτομέρειες υλοποιήσης.

\section{Περιγραφή λειτουργίας}
\subsection{common.h}
Στο παραπάνω αρχείο υπάρχουν:
\begin{itemize}
 \item Δήλωση κοινών βιβλιοθηκών που χρειάζονται τα άλλα δύο αρχεία
 \item Συναρτήσεις ελέγχου fatal και debug
 \item Γενικές μεταβλητές του προγράμματος
\end{itemize}

\subsection{client.c}
Ενέργειες του client:
\begin{itemize}
 \item Άνοιγμα κοινού socket για επικοινωνία με τον server
 \item Δημιουργία παραγγελίας
 \begin{itemize}
 \item Αν υπάρχουν ορίσματα δημιουργεί μια τυχαία παραγγελία
 \item Αν όχι, ο χρήστης δίνει είσοδο
 \end{itemize}
 \item Παραμένει ανοιχτός για να λαμβάνει μηνύματα του server (πχ cocacoles ή έλλειψη μνήμης) και κλείνει μόλις λάβει το μήνυμα DONE 
\end{itemize}
\pagebreak
\subsection{server.c}
Η κεντρική main του server το μόνο που κάνει είναι συνεχώς να ακούει για παραγγελίες και μόλις λάβει μία παραγγελία να καλεί την \_init\_proc η οποία θα δημιουργήσει ένα νέο thread για την διαχείρισή της (\ref{order}) και συνεχίζει να κάνει accept. Ο έλεγχος για καθυστερημένες παραγγελίες αντί να είναι βάρος του server είναι αρμοδιότητα του thread της κάθε παραγγελίας.

\subsubsection{Thread παραγγελίας}
\label{order}
Εσωτερικά το κάθε παιδί λαμβάνει την παραγγελία απο τον client και την κάνει parse σε ένα πίνακα κωδικών (0-2).
Αοφύ λάβει την παραγγελία δημιουργεί και ένα νέο thread delay το οποίο μετράει σε διαστήματα TVERYLONG και ενημερώνει για κοκακολα τον client, έως ότου το thread παραγγελίας το καταστρέψει(μετά την ολοκλήρωση του delivery).
\paragraph{}
Έπειτα προσθέτει την παραγγελία στην λίστα παραγγελιών (λεπτομέρειες στο section \ref{list_info}) και ξεκινάει η διαδικασία ανάθεσης σε ψήστη. H παραγγελία εκτελεί ένα loop μέχρι να δώσει επιτυχώς όλες τις πίτσες της σε ψήστες. Σε κάθε loop κλειδώνεται το mutex baker\_lock έτσι ώστε να μειωθεί το num\_bakers ή να αναμένει στο condition variable free\_bakers εως ότου ένας ψήστης ελευθερωθεί. Αφού βρεθεί ψήστης δημιουργεί ένα αυτόνομo thread ψήστη με όρισμα τον τύπο της πίτσας που καλείται να ψήσει
(\ref{baker}). 
\paragraph{}
Μόλις δώσει όλες τις πίτσες της σε ψήστες βγαίνει απο το loop ανεξαρτήτως αν έχει τελειώσει το ψήσιμο και περιμένει τους ψήστες(παιδιά της) να τελειώσουν με join. Μόλις όλοι οι ψήστες τελειώσουν ακολουθείται η ίδια διαδικασία για την ανάθεση σε delivery (χωρίς το loop προφανώς).
Μόλις κάνει join και τον deliverά ακυρώνει το thread καθυστέρησης και διαγράφει την παραγγελία απο την λίστα.

\subsubsection{Baker/delivery thread}
\label{baker}
Το thread του baker με αυτό του delivery είναι πανομοιότυπα 
και ο μόνος λόγος που είναι ξεχωριστές συναρτήσεις είναι για να είναι πιο ξεκάθαρο.
  
Το thread του baker/delivery δημιουργεί ένα δικό του mutex και condition variable στο οποίο περιμένει μέχρι να γίνει timeout, διότι η sleep παρατηρήθηκε ότι δεν δίνει ακριβή αποτελέσματα. Έπειτα αυξάνει τον αριθμό διαθέσιμων ψηστών και στέλνει signal στην free\_bakers για να ενημερώσει τις παραγγελίες που περιμένουν ελεύθερο ψήστη.

\subsubsection{Λίστα παραγγελιών}
\label{list_info}
Η λίστα παραγγελιών υλοποιείται με μια διπλά συνδεδεμένη λίστα για γρηγορότερους χρόνους σβησίματος και εισαγωγής αλλά και για να εκτελούνται παράλληλα οι παραγγελίες που φτάνουν.
\paragraph{}
Η λίστα παραγγελιών υλοποιείται σε ένα σταθερού μεγέθους πίνακα απο structs order\_info. Διαθέτει condition variable και mutex για την ελεγχόμενη εισαγωγή/διαγραφή σε αυτήν.
\paragraph{}
Μιας και η λίστα είναι σταθερού μεγέθους θα τοποθετεί σειριακά τις παραγγελίες που εισάγονται μέχρι να γεμίσει MAX\_ORDERS. Παρόλ' αυτά μόλις διαγραφεί μια παραγγελία απο αυτήν, εισάγει την, πλέον ελεύθερη, θέση της σε μία στοίβα ελεύθερων θέσεων. Έτσι ο server μπορεί να εξυπηρετήσει όσες παραγγελίες και να έρθουν αφού όταν μια παραγγελία εισάγεται στην λίστα τσεκάρει αν έχει γεμίσει ήδη μια φορά και αν ναι θα μπεί σε θέση που θα κάνει pull απο την στοίβα.

\subsubsection{Στοίβα διαχείρισης μνήμης}
\label{stack}
Η στοίβα διαχείρισης της μνήμης της λίστας είναι σταθερού μεγέθους ίδιου με το μέγεθος της λίστας. Διαθέτει mutex για τον έλεγχο πρόσβασης σε αυτή και ένα condition variable το οποίο σηματοδοτείται όταν υπάρχει κάποιο στοιχείο στην λίστα.
\paragraph{}
Οι διαδικασίες του pull και του push ελέγχονται απο το mutex.
Επιπρόσθετα στην pull υπάρχει έλεγχος για το αν η στοίβα έχει στοιχεία
με το condition var opt.full επειδή έτσι αν και το max\_orders είναι 100 μπορώ να στείλω 200 παραγγελίες και αυτές να περιμένουν στην pull για ελεύθερη θέση.
Στην push δεν υπάρχει τέτοιος έλεγχος διότι η λογική του προγράμματος εκτελεί παράλληλα MAX\_ORDERS παραγγελίες άρα πάντα υπάρχει κενή θέση στην στοίβα. Η opt.full γίνεται signal μετά το πέρας μιας push.

\subsubsection{Καθυστερημένες παραγγελίες}
\label{late}
Ο έλεγχος καθυστερημένων παραγγελιών είναι αρμοδιότητα της κάθε παραγγελίας και όχι του server για λόγους ταχύτητας στην εξυπηρέτηση νέων πελατών.
\paragraph{}
Με το που ξεκινάει ένα thread παρααγγελίας, αφού λάβει την παραγγελία του ξεκινάει και ένα δεύτερο thread. Αυτό το thread μόλις περάσει tverylong χρόνος θα αναλάβει να ενημερώσει τον client ότι θα πάρει cocacola, και θα συνεχίσει το loop έως ότου να γίνει cancel απο το thread παραγγελίας.

\end{document}