%xelatex
\documentclass{article}
\usepackage[margin=1.3in]{geometry}
\usepackage{xltxtra}
\usepackage{xgreek}
\setmainfont[Mapping=tex-text]{Kerkis}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue]{hyperref}
\title{Λειτουργικά Συστήματα Ι, Ασκηση 1}
\author{Σπύρος Σειμένης 5070}

\begin{document}
\maketitle

\section{Εισαγωγή}
Η πλήρης λειτουργία του κώδικα περιγράφεται αναλυτικά με σχόλια μέσα στα αρχεία. Παρακάτω περιγράφω τις δομές που έχω χρησιμοποιήσει και μια εκτέλεση του προγράμματος, δεν θα αναφερθώ σε λεπτομέρειες υλοποιήσης.

\section{Περιγραφή λειτουργίας}
\subsection{common.h}
Στο παραπάνω αρχείο υπάρχουν:
\begin{itemize}
 \item Δήλωση κοινών βιβλιοθηκών που χρειάζονται τα άλλα δύο αρχεία
 \item directives ελέγχου \_STACKOP\_ και \_DEBUG\_ που ελέγχουν προαιρετικές λειτουργίες του server
 \begin{itemize}
  \item \_STACKOP\_ αν δηλωθεί ο server μπορεί να χειριστεί παραπάνω παραγγελίες απο το MAX\_ORDERS (\ref{stack}). Είναι ενεργοποιημένο απο deafult.
  \item \_DEBUG\_ αν δηλωθεί ο server θα εκτυπώνει παραπάνω πληροφορίες για την λειτουργία του. Δεν είναι ενεργοποιημένο απο default.
 \end{itemize}
 \item Συναρτήσεις ελέγχου fatal και debug
 \item Γενικές μεταβλητές του προγράμματος
\end{itemize}

\subsection{client.c}
Ενέργειες του client:
\begin{itemize}
 \item Άνοιγμα κοινού socket για επικοινωνία με τον server
 \item Δημιουργία παραγγελίας
 \begin{itemize}
 \item Αν υπάρχουν ορίσματα δημιουργεί μια τυχαία παραγγελίας
 \item Αν όχι, ο χρήστης δίνει είσοδο
 \end{itemize}
 \item Παραμένει ανοιχτός για να λαμβάνει μηνύματα του server (πχ cocacoles ή έλλειψη μνήμης) και κλείνει μόλις λάβει το μήνυμα DONE 
\end{itemize}
\pagebreak
\subsection{server.c}
Η κεντρική main του server το μόνο που κάνει είναι συνεχώς να ακούει για παραγγελίες και μόλις λάβει μία παραγγελία κάνει fork για την διαχείρισή της (\ref{order}) και συνεχίζει να κάνει accept. Ο έλεγχος για καθυστερημένες παραγγελίες αντί να είναι βάρος του server είναι αρμοδιότητα του fork της κάθε παραγγελίας.

\subsubsection{Fork παραγγελίας}
\label{order}
Εσωτερικά το κάθε παιδί λαμβάνει την παραγγελία απο τον client και την κάνει parse σε ένα πίνακα κωδικών (0-2).Αφού λάβει την παραγγελία εκκινεί τον timer.
\paragraph{}
Έπειτα προσθέτει την παραγγελία στην λίστα παραγγελιών σε αναμονή pending (λεπτομέρειες στο section \ref{list_info}) και ξεκινάει η διαδικασία ανάθεσης σε ψήστη. H παραγγελία εκτελεί ένα loop μέχρι να δώσει επιτυχώς όλες τις πίτσες της σε ψήστες. Κάθε φορά προσπαθεί να κατεβάσει το semaphore που ελέγχει τους ψήστες(αρχικοποιείται με NBAKERS), αν τα καταφέρει θα πει ότι υπήρχε διαθέσιμος ψήστης και κάνει fork έναν ψήστη (\ref{baker}). Μόλις δώσει όλες τις πίτσες της σε ψήστες βγαίνει απο το loop ανεξαρτήτως αν έχει τελειώσει το ψήσιμο και περιμένει τους ψήστες(παιδιά της) να τελειώσουν. Μόλις τελειώσει η διαδικασία του ψησίματος, το order διαγράφεται απο την pending list και εισάγεται στην ready list. Απο κει και μετά 
ακολουθείται η ίδια διαδικασία για ανάθεση σε delivery.

\subsubsection{Baker/delivery process}
\label{baker}
Το process του baker με αυτό του delivery είναι πανομοιότυπα στην λειτουργία με τις εξής διαφορές:
\begin{itemize}
 \item ότι το κάθε ένα περιμένει διαφορετικούς χρόνους όπως είναι λογικό
 \item γράφουν σε ξεχωριστές shared memories που ελεγχονται με ξεχωριστούς semaphores
 \item έχουν διαφορετικούς semaphores ελέγχου pending->sem\_res για ψήστες, ready->sem\_res για deliveries
 \item κάθε παραγγελία αναθέτει σε παραπάνω απο ένα ψήστες αλλά σε ένα deliverα
\end{itemize}
Γενικά ένας baker/delivery κάνει απλά sleep για τον απαραίτητο χρόνο έπειτα ενημερώνει το order κάνοντας -1 το status του πατέρα του στην shared memory.Αφού τελειώσει αυξάνει τον αντίστοιχο semaphore sem\_res.

\subsubsection{Λίστα παραγγελιών}
\label{list_info}
Η λίστα παραγγελιών υλοποιείται με μια διπλά συνδεδεμένη λίστα για γρηγορότερους χρόνους σβησίματος και εισαγωγής. Κάθε κόμβος κρατάει το status της παραγγελίας και το pid της διεργασίας που την έχει αναλάβει.
\paragraph{}
Η λίστα αποθηκεύεται στην shared memory και ξεκινάει καταλαμβάνει χώρο απο την αρχή της shared memory μέχρι MAX\_ORDERS*μέγεθος του κόμβου order\_info. Επειδή χρησιμοποιώ 2 λίστες για πιο γρήγορους χρόνους ώστε να μπορούν delivery και bakers να προσπελαύουν ταυτόχρονα τις απαραίτητες πληροφορίες, χρειάζεται για κάθε λίστα να διατηρώ τα στοιχεία της σε ένα struct list\_info.
\paragraph{}
Συνολικά την shared memory που κάνω allocate την χωρίζω σε 2 τμήματα ένα για τους bakers και ένα για τους deliveries. Κάθε τμήμα αποτελείται απο τα εξής:
\begin{itemize}
 \item Την παραπάνω λίστα, η pending για το ένα, η ready για το άλλο.
 \item Ένα struct list\_info το οποίο αποθηκεύει τις πληροφορίες που χρειάζονται για να ελέγχω την λίστα και το τμήμα γενικά.
 \item Την στοίβα διαχείρισης μνήμης(\ref{stack}).
 \item Τον semaphore για τον έλεγχο πρόσβασης στο τμήμα
 \item Τους semaphores για τον έλεγχο της στοίβας(\ref{stack}).
 \item Τον semaphore για το resource που ελέχγχει η κάθε λίστα (bakers για την pending, deliveries για την ready)
\end{itemize}

\subsubsection{Στοίβα διαχείρισης μνήμης}
\label{stack}
Χωρίς την προσθήκη της στοίβας μόλις o server δεχτεί παραπάνω απο MAX\_ORDERS θα πάψει να δέχεται παραγγελίες. Για να μπορώ να παραχωρώ συνέχεια μνήμη η εισαγωγή στην shared memory γίνεται ως εξής. Μέχρι να καλυφθεί το max\_orders η παραγγελίες εισάγονται στην λίστα σειριακά (μεταβλητή offset). Μόλις τελειώσει το πρώτο γέμισμα της λίστας (offset == MAX\_ORDERS) οι υπόλοιπες παραγγελίες εισάγονται σε διεύθυνση που κάνουν pull απο το stack. Μόλις μια παραγγελία διαγράφεται απο μια λίστα κάνει push την θέση της στο stack.

\subsubsection{Καθυστερημένες παραγγελίες}
\label{late}
Ο έλεγχος των καθυστερημένων παραγγελιών γίνεται χρησιμοποιώντας POSIX timers μέσα σε κάθε fork παραγγελίας.
\paragraph{}
Με το που ξεκινάει ένα fork παραγγελίας, αφού λάβει την παραγγελία του ξεκινάει και ένας timer. Αυτός ο timer μόλις περάσει tverylong χρόνος θα αναλάβει να στείλει στην παραγγελία ένα sigalarm με το οποίο ενημερώνεται ο client ότι θα πάρει cocacola, και θα ξαναθέσει τον εαυτό του να ξαναστείλει σήμα σε tverylong χρόνο. Ο handler του SIGALRM και του SIGINT έχουν ως flags το SA\_RESTART ώστε να μην επηρεάζουν την λειτουργία του κώδικα σε περίπτωση που ένα σήμα διακόψει κάποιο blocking system call.

\end{document}